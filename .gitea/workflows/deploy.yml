# 工作流的名称
name: Build and Deploy Full Stack Project

# 触发条件：当有代码 push 到 master 分支时触发
on:
  push:
    branches:
      - master

# 任务列表
jobs:
  build-and-deploy:
    # 运行环境标签，必须与您自托管运行器设置的标签完全一致
    runs-on: windows-iis

    # 环境变量，用于统一定义路径，便于维护
    env:
      FRONTEND_DIR: ./opsboard-frontend
      BACKEND_DIR: ./opsboard-backend
      DEPLOY_DIR: C:\inetpub\wwwroot\opsboard-web

    # 任务包含的步骤
    steps:
      # 第1步：检出代码
      - name: Checkout Repository
        uses: actions/checkout@v4

      # ------------------- 后端构建部分 -------------------
      # 第2步：设置 Go 环境
      # 假设您已在运行器服务器上预装了 Go，此步骤将验证并使用该版本。
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          # 移除 go-version 以使用系统 PATH 中的 Go。
          # check-latest 仍会检查是否有新版本，但不会下载。
          check-latest: true
          # 禁用 Action 的缓存，因为我们依赖的是系统级安装。
          cache: false

      # 第3步：构建 Go 后端应用
      - name: Build Go Backend
        working-directory: ${{ env.BACKEND_DIR }}
        run: go build -o opsboard-backend.exe .

      # ------------------- 前端构建部分 -------------------
      # 第4步：设置 Node.js 环境
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: '${{ env.FRONTEND_DIR }}/package-lock.json'

      # 第5步：安装前端依赖并执行构建
      - name: Install Dependencies and Build Frontend
        working-directory: ${{ env.FRONTEND_DIR }}
        run: |
          npm install
          npm run build

      # ------------------- 部署部分 -------------------
      # 第6步：部署所有构建产物到 IIS 目录
      - name: Deploy to IIS Directory
        shell: powershell
        run: |
          Write-Host "Preparing deployment to ${{ env.DEPLOY_DIR }}..."
          
          # 检查并创建目标目录
          if (-not (Test-Path "${{ env.DEPLOY_DIR }}")) {
            New-Item -ItemType Directory -Force -Path "${{ env.DEPLOY_DIR }}"
          }
          
          Write-Host "Clearing destination directory..."
          # 清理目录，但保留日志文件和 NSSM 可能创建的其他非构建文件
          Get-ChildItem -Path "${{ env.DEPLOY_DIR }}" -Exclude "stdout.log", "stderr.log" | Remove-Item -Recurse -Force
          
          Write-Host "Copying frontend build artifacts..."
          Copy-Item -Path "${{ env.FRONTEND_DIR }}\dist\*" -Destination "${{ env.DEPLOY_DIR }}" -Recurse -Force
          
          Write-Host "Copying backend executable..."
          Copy-Item -Path "${{ env.BACKEND_DIR }}\opsboard-backend.exe" -Destination "${{ env.DEPLOY_DIR }}" -Force
          
          # 警告：直接复制 .env 文件可能存在安全风险。在生产环境中，推荐使用 GitHub/Gitea Secrets 配合脚本生成 .env 文件。
          Write-Host "Copying backend configuration..."
          Copy-Item -Path "${{ env.BACKEND_DIR }}\.env" -Destination "${{ env.DEPLOY_DIR }}" -Force
          
          # 复制 IIS 反向代理配置文件
          Write-Host "Copying web.config..."
          Copy-Item -Path ".\web.config" -Destination "${{ env.DEPLOY_DIR }}" -Force
          
          Write-Host "Deployment successful!"

      # 第7步：使用 NSSM 创建或重启 Go 后端服务
      - name: Create or Restart Go Backend Service with NSSM
        if: always() # 确保此步骤总是运行，以便在部署失败时也能尝试重启服务
        shell: powershell
        run: |
          $serviceName = "opsboard-backend-service"
          
          # 检查 NSSM 是否可用
          if (-not (Get-Command nssm -ErrorAction SilentlyContinue)) {
            Write-Error "NSSM is not found in PATH. Please install it on the runner server."
            exit 1
          }

          # 检查服务是否存在
          if (-not (Get-Service $serviceName -ErrorAction SilentlyContinue)) {
            Write-Host "Service '$serviceName' not found. Creating it..."
            nssm install $serviceName "${{ env.DEPLOY_DIR }}\opsboard-backend.exe"
            nssm set $serviceName AppDirectory "${{ env.DEPLOY_DIR }}"
            nssm set $serviceName AppStdout "${{ env.DEPLOY_DIR }}\stdout.log"
            nssm set $serviceName AppStderr "${{ env.DEPLOY_DIR }}\stderr.log"
            nssm set $serviceName Start SERVICE_AUTO_START
            Write-Host "Service '$serviceName' created."
            Start-Service -Name $serviceName
          } else {
            Write-Host "Service '$serviceName' found. Restarting..."
            Restart-Service -Name $serviceName -Force
          }
          
          Write-Host "Service '$serviceName' is running."